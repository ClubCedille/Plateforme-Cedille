name: Create weekly issues discussion

on:
  workflow_dispatch:

permissions:
  contents: read
  issues: read
  discussions: write

env:
  GH_TOKEN: ${{ secrets.PROJECTS_TOKEN }}

jobs:
  create-discussion:
    runs-on: ubuntu-latest

    steps:
      - name: Fetch project issues and create discussion
        env:
          GH_TOKEN: ${{ secrets.PROJECTS_TOKEN }}
          ORG: ClubCedille
          TARGET_REPO: Plateforme-Cedille
          CATEGORY_ID: DIC_kwDOJzjWms4CyD_J
          PROJECT_ID: PVT_kwDOAGLsXs4AR-hq
          PROJECT_FIELD_ID: PVTSSF_lADOAGLsXs4AR-hqzggfaoM
          STATUS_FIELD_ID: PVTSSF_lADOAGLsXs4AR-hqzgLeuKs
        run: |
          gh --version
          set -e

          # Define project and status sort order
          PROJECT_ORDER=("Services" "Déploiements" "Plateforme-Cedille" "Club-ops" "Documentation & Onboarding" "Web Dev" "App Dev")
          STATUS_ORDER=("Backlog" "Todo" "In Progress" "In Review" "Done" "Won't Do")

          echo "Fetching last discussion date..."
          LAST_DISCUSSION_DATE=$(gh api graphql -f query='
          query($owner:String!, $name:String!, $category:ID!) {
            repository(owner: $owner, name: $name) {
              discussions(first: 1, categoryId: $category, orderBy: {field: CREATED_AT, direction: DESC}) {
                nodes {
                  createdAt
                }
              }
            }
          }' -f owner="$ORG" -f name="$TARGET_REPO" -f category="$CATEGORY_ID" --jq '.data.repository.discussions.nodes[0].createdAt // empty')

          if [ -z "$LAST_DISCUSSION_DATE" ]; then
            echo "No previous discussion found. Including all issues."
            LAST_DISCUSSION_DATE="1970-01-01T00:00:00Z"
          else
            echo "Last discussion was created at: $LAST_DISCUSSION_DATE"
          fi

          echo "Fetching project items with pagination..."

          # Initialize variables for pagination
          all_items="[]"
          has_next_page=true
          end_cursor=""

          # Fetch all pages
          while [ "$has_next_page" = "true" ]; do
            echo "Fetching page with cursor: ${end_cursor:-'(first page)'}"

            # Build query based on whether we have a cursor
            if [ -z "$end_cursor" ]; then
              # First page - no cursor
              page_data=$(gh api graphql -f query='
              query($project:ID!) {
                node(id: $project) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      pageInfo {
                        hasNextPage
                        endCursor
                      }
                      nodes {
                        id
                        updatedAt
                        content {
                          ... on Issue {
                            title
                            url
                            number
                            createdAt
                            repository {
                              name
                            }
                          }
                        }
                        fieldValues(first: 20) {
                          nodes {
                            ... on ProjectV2ItemFieldSingleSelectValue {
                              name
                              field {
                                ... on ProjectV2SingleSelectField {
                                  id
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }' -f project="$PROJECT_ID")
            else
              # Subsequent pages - with cursor
              page_data=$(gh api graphql -f query='
              query($project:ID!, $cursor:String!) {
                node(id: $project) {
                  ... on ProjectV2 {
                    items(first: 100, after: $cursor) {
                      pageInfo {
                        hasNextPage
                        endCursor
                      }
                      nodes {
                        id
                        updatedAt
                        content {
                          ... on Issue {
                            title
                            url
                            number
                            createdAt
                            repository {
                              name
                            }
                          }
                        }
                        fieldValues(first: 20) {
                          nodes {
                            ... on ProjectV2ItemFieldSingleSelectValue {
                              name
                              field {
                                ... on ProjectV2SingleSelectField {
                                  id
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }' -f project="$PROJECT_ID" -f cursor="$end_cursor")
            fi

            # Extract pagination info
            has_next_page=$(echo "$page_data" | jq -r '.data.node.items.pageInfo.hasNextPage')
            end_cursor=$(echo "$page_data" | jq -r '.data.node.items.pageInfo.endCursor')

            # Append items to all_items
            page_items=$(echo "$page_data" | jq '.data.node.items.nodes')
            all_items=$(echo "$all_items" | jq --argjson page "$page_items" '. + $page')

            echo "Fetched $(echo "$page_items" | jq 'length') items. Total: $(echo "$all_items" | jq 'length')"
          done

          echo "Total items fetched: $(echo "$all_items" | jq 'length')"

          echo "Filtering items updated or created since last discussion..."

          filtered_items=$(echo "$all_items" | jq --arg last_date "$LAST_DISCUSSION_DATE" '
            map(
              select(
                .content != null and
                (.updatedAt > $last_date or .content.createdAt > $last_date)
              )
            )
          ')

          echo "Total filtered items: $(echo "$filtered_items" | jq 'length')"

          # Check if there are any filtered items
          filtered_count=$(echo "$filtered_items" | jq 'length')
          if [ "$filtered_count" -eq 0 ]; then
            echo "No issues updated or created since last discussion. Exiting."
            exit 0
          fi

          echo "Formatting and sorting issues..."

          formatted=$(echo "$filtered_items" | jq -r --argjson PROJECT_ORDER "$(printf '%s\n' "${PROJECT_ORDER[@]}" | jq -R . | jq -s .)" \
          --argjson STATUS_ORDER "$(printf '%s\n' "${STATUS_ORDER[@]}" | jq -R . | jq -s .)" \
          --arg PROJECT_FIELD_ID "$PROJECT_FIELD_ID" \
          --arg STATUS_FIELD_ID "$STATUS_FIELD_ID" \
          '
          map(
            {
              title: .content.title,
              url: (.content.url // ""),
              number: (.content.number // 0),
              repo: (.content.repository.name // "No Repo"),
              project: (.fieldValues.nodes[] | select(.field.id == $PROJECT_FIELD_ID) | .name // "No Project"),
              status: (.fieldValues.nodes[] | select(.field.id == $STATUS_FIELD_ID) | .name // "No Status"),
              updatedAt: .updatedAt,
              createdAt: .content.createdAt
            }
          )
          | sort_by(
            (.project as $p | $PROJECT_ORDER | index($p) // 999),
            (.status as $s | $STATUS_ORDER | index($s) // 999)
          )
          | group_by(.project)
          | map(
            "## " + (.[0].project) + "\n\n" +
            (
              group_by(.status)
              | map(
                "### " + (.[0].status) + "\n" +
                (map(
                  "- [" + .repo + "] " + .title +
                  (if .url != "" and .number != 0 then " [#" + (.number | tostring) + "](" + .url + ")" else "" end)
                ) | join("\n"))
              )
              | join("\n\n")
            )
          )
          | join("\n\n")
          ')

          body=$(cat <<EOF
          ## Weekly project overview – Backlog CEDILLE

          _Issues updated or created since $(date -d "$LAST_DISCUSSION_DATE" '+%B %d, %Y' 2>/dev/null || echo "last discussion")_

          $formatted
          EOF
          )

          echo "Resolving repository ID..."

          REPO_ID=$(gh api graphql -f query='
          query($owner:String!, $name:String!) {
            repository(owner: $owner, name: $name) {
              id
            }
          }' -f owner="$ORG" -f name="$TARGET_REPO" --jq '.data.repository.id')

          echo "Repository ID: $REPO_ID"

          echo "Creating discussion..."

          discussion_url=$(gh api graphql -f query='
          mutation($repoId:ID!, $title:String!, $body:String!, $category:ID!) {
            createDiscussion(input:{
              repositoryId: $repoId
              title: $title
              body: $body
              categoryId: $category
            }) {
              discussion {
                url
              }
            }
          }' \
          -f repoId="$REPO_ID" \
          -f title="CEDILLE Meeting - H26 ($(LC_TIME=fr_FR.UTF-8 date '+%d %B %Y'))" \
          -f body="$body" \
          -f category="$CATEGORY_ID" --jq '.data.createDiscussion.discussion.url')

          echo "Discussion created successfully: $discussion_url"
